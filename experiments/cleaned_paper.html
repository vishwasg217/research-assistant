<!DOCTYPE html>
<h1>GLM: General Language Model Pretraining 
<br/>with Autoregressive Blank Infilling</h1>
Zhengxiao Du<sup>∗1,2</sup>  Yujie Qian<sup>∗3</sup>  Xiao Liu<sup>1,2</sup>  Ming Ding<sup>1,2</sup>  Jiezhong Qiu<sup>1,2</sup>
<br/>Zhilin Yang<sup>2</sup><sup>2</sup>2Corresponding authors.<math></math>  Jie Tang<sup>2</sup><sup>2</sup>2Corresponding authors.<math></math>
<br/><sup>1</sup>Tsinghua University  <sup>2</sup>Beijing Academy of Artificial Intelligence (BAAI)
<br/><sup>3</sup>MIT CSAIL  <sup>4</sup>Shanghai Qi Zhi Institute
<br/>zx-du20@mails.tsinghua.edu.cn yujieq@csail.mit.edu
<br/>{zhiliny,jietang}@tsinghua.edu.cn
<h6>Abstract</h6>
<p>There have been various types of pretraining architectures including autoencoding models (e.g., BERT), autoregressive models (e.g., GPT), and encoder-decoder models (e.g., T5). However, none of the pretraining frameworks performs the best for all tasks of three main categories including natural language understanding (NLU), unconditional generation, and conditional generation. We propose a General Language Model (GLM) based on autoregressive blank infilling to address this challenge.
GLM improves blank filling pretraining by adding 2D positional encodings and allowing an arbitrary order to predict spans, which results in performance gains over BERT and T5 on NLU tasks.
Meanwhile, GLM can be pretrained for different types of tasks by varying the number and lengths of blanks.
On a wide range of tasks across NLU, conditional and unconditional generation, GLM outperforms BERT, T5, and GPT given the same model sizes and data, and achieves the best performance from a single pretrained model with 1.25<math></math> parameters of BERT<math></math>, demonstrating its generalizability to different downstream tasks.<sup>1</sup><sup>1</sup>1The code and pre-trained models are available at <a href="https://github.com/THUDM/GLM">https://github.com/THUDM/GLM</a></p>
<sup>1</sup><sup>1</sup>footnotetext: The first two authors contributed equally.
<section>
<h2>
1 Introduction</h2>
<p>Language models pretrained on unlabeled texts have substantially advanced the state of the art in various NLP tasks, ranging from natural language understanding (NLU) to text generation <cite>Radford et al. (<a href="#bib.bib28">2018a</a>); Devlin et al. (<a href="#bib.bib9">2019</a>); Yang et al. (<a href="#bib.bib46">2019</a>); Radford et al. (<a href="#bib.bib29">2018b</a>); Raffel et al. (<a href="#bib.bib30">2020</a>); Lewis et al. (<a href="#bib.bib18">2019</a>); Brown et al. (<a href="#bib.bib4">2020</a>)</cite>. Downstream task performance as well as the scale of the parameters have also constantly increased in the past few years.</p>
<figure><img src="/html/2103.10360/assets/x1.png"/>
<figcaption>Figure 1: Illustration of GLM. We blank out text spans (green part) and generate them autoregressively. (Some attention edges are omitted; cf. Figure <a href="#S1.F2">2</a>.)</figcaption>
</figure>
<p>In general, existing pretraining frameworks can be categorized into three families: autoregressive, autoencoding, and encoder-decoder models. Autoregressive models, such as GPT <cite>Radford et al. (<a href="#bib.bib28">2018a</a>)</cite>, learn left-to-right language models. While they succeed in long-text generation and show few-shot learning ability when scaled to billions of parameters <cite>Radford et al. (<a href="#bib.bib29">2018b</a>); Brown et al. (<a href="#bib.bib4">2020</a>)</cite>, the inherent disadvantage is the unidirectional attention mechanism, which cannot fully capture the dependencies between the context words in NLU tasks. Autoencoding models, such as BERT <cite>Devlin et al. (<a href="#bib.bib9">2019</a>)</cite>, learn bidirectional context encoders via denoising objectives, e.g. Masked Language Model (MLM). The encoders
produce contextualized representations that suit natural language understanding tasks, but could not be directly applied for text generation. Encoder-decoder models adopt bidirectional attention for the encoder, unidirectional attention for the decoder, and cross attention between them <cite>Song et al. (<a href="#bib.bib41">2019</a>); Bi et al. (<a href="#bib.bib3">2020</a>); Lewis et al. (<a href="#bib.bib18">2019</a>)</cite>. They are typically deployed in conditional generation tasks, such as text summarization and response generation.
<sup>2</sup><sup>2</sup>2Unconditional generation refers to generating text as a language model without finetuning, while conditional generation refers to sequence-to-sequence tasks..
T5 <cite>Raffel et al. (<a href="#bib.bib30">2020</a>)</cite> unifies NLU and conditional generation via encoder-decoder models but requires more parameters to match the performance of BRET-based models such as RoBERTa <cite>Liu et al. (<a href="#bib.bib21">2019</a>)</cite> and DeBERTa <cite>He et al. (<a href="#bib.bib14">2021</a>)</cite>.</p>
<p>None of these pretraining frameworks is flexible enough to perform competitively across all NLP tasks. Previous works have tried to unify different frameworks by combining their objectives via multi-task learning <cite>Dong et al. (<a href="#bib.bib11">2019</a>); Bao et al. (<a href="#bib.bib2">2020</a>)</cite>. However, since the autoencoding and autoregressive objectives differ by nature, a simple unification cannot fully inherit the advantages of both frameworks.</p>
<p>In this paper, we propose a pretraining framework named GLM (General Language Model), based on autoregressive blank infilling. We randomly blank out continuous spans of tokens from the input text, following the idea of autoencoding, and train the model to sequentially reconstruct the spans, following the idea of autoregressive pretraining (see <a href="#S1.F1">Figure 1</a>). While blanking filling has been used in T5 <cite>Raffel et al. (<a href="#bib.bib30">2020</a>)</cite> for text-to-text pretraining, we propose two improvements, namely span shuffling and 2D positional encoding. Empirically, we show that with the same amount of parameters and computational cost, GLM significantly outperforms BERT on the SuperGLUE benchmark by a large margin of 4.6% – 5.0% and outperforms RoBERTa and BART when pretrained on a corpus of similar size (158GB). GLM also significantly outperforms T5 on NLU and generation tasks with fewer parameters and data.</p>
<p>Inspired by Pattern-Exploiting Training (PET) <cite>Schick and Schütze (<a href="#bib.bib35">2020a</a>)</cite>, we reformulate NLU tasks as manually-crafted cloze questions that mimic human language. Different from the BERT-based models used by PET, GLM can naturally handle multi-token answers to the cloze question via autoregressive blank filling.</p>
<p>Furthermore, we show that by varying the number and lengths of missing spans, the autoregressive blank filling objective can pretrain language models for conditional and unconditional generation. Through multi-task learning of different pretraining objectives, a single GLM can excel in both NLU and (conditional and unconditional) text generation.
Empirically, compared with standalone baselines, GLM with multi-task pretraining achieves improvements in NLU, conditional text generation, and language modeling tasks altogether by sharing the parameters.</p>
<figure><img src="/html/2103.10360/assets/x2.png"/>
<figcaption>Figure 2: GLM pretraining. (a) The original text is <math></math>. Two spans <math></math> and <math></math> are sampled. (b) Replace the sampled spans with [M] in Part A, and shuffle the spans in Part B. (c) GLM autoregressively generates Part B. Each span is prepended with [S] as input and appended with [E] as output. 2D positional encoding represents inter- and intra-span positions. (d) Self-attention mask. Grey areas are masked out. Part A tokens can attend to themselves (blue frame) but not B. Part B tokens can attend to A and their antecedents in B (yellow and green frames correspond to the two spans). <math></math>, <math></math>, and <math></math>.</figcaption>
</figure>
</section>
<section>
<h2>
2 GLM Pretraining Framework</h2>
<p>We propose a general pretraining framework GLM based on a novel autoregressive blank infilling objective. GLM formulates NLU tasks as cloze questions that contain task descriptions, which can be answered by autoregressive generation.</p>
<section>
<h3>
2.1 Pretraining Objective</h3>
<section>
<h4>
2.1.1 Autoregressive Blank Infilling</h4>
<p>GLM is trained by optimizing an autoregressive blank infilling objective. Given an input text <math></math>, multiple text spans <math></math> are sampled, where each span <math></math> corresponds to a series of consecutive tokens <math></math> in <math></math>. Each span is replaced with a single <math></math> token, forming a corrupted text <math></math>. The model predicts the missing tokens in the spans from the corrupted text in an autoregressive manner, which means when predicting the missing tokens in a span, the model has access to the corrupted text <em>and</em> the previously predicted spans. To fully capture the interdependencies between different spans, we randomly permute the order of the spans, similar to the permutation language model <cite>Yang et al. (<a href="#bib.bib46">2019</a>)</cite>.
Formally, let <math></math> be the set of all possible permutations of the length-<math></math> index sequence <math></math>, and <math></math> be <math></math>, we define the pretraining objective as</p>
<table>
<tbody><tr>
<td></td>
<td><math></math></td>
<td></td>
<td>(1)</td>
</tr></tbody>
</table>
<p>We always generate the tokens in each blank following a left-to-right order, i.e. the probability of generating the span <math></math> is factorized as:</p>
<table>
<tbody><tr>
<td></td>
<td><math></math></td>
<td></td>
<td>(2)</td>
</tr></tbody>
</table>
<p>We implement the autoregressive blank infilling objective with the following techniques. The input <math></math> is divided into two parts: Part A is the corrupted text <math></math>, and Part B consists of the masked spans. Part A tokens can attend to each other, but cannot attend to any tokens in B. Part B tokens can attend to Part A and antecedents in B, but cannot attend to any subsequent tokens in B. To enable autoregressive generation, each span is padded with special tokens <math></math> and <math></math>, for input and output respectively. In this way, our model automatically learns a bidirectional encoder (for Part A) and a unidirectional decoder (for Part B) in a unified model. The implementation of GLM is illustrated in <a href="#S1.F2">Figure 2</a>.</p>
<p>We randomly sample spans of length drawn from a Poisson distribution with <math></math>. We repeatedly sample new spans until at least 15% of the original tokens are masked. Empirically, we have found that the 15% ratio is critical for good performance on downstream NLU tasks.</p>
</section>
<section>
<h4>
2.1.2 Multi-Task Pretraining</h4>
<p>In the previous section, GLM masks short spans and is suited for NLU tasks. However, we are interested in pretraining a single model that can handle both NLU and text generation. We then study a multi-task pretraining setup, in which a second objective of generating longer text is jointly optimized with the blank infilling objective. We consider the following two objectives:</p>
<ul>
<li>
<p>Document-level. We sample a single span whose length is sampled from a uniform distribution over 50%–100% of the original length. The objective aims for long text generation.</p>
</li>
<li>
<p>Sentence-level. We restrict that the masked spans must be full sentences. Multiple spans (sentences) are sampled to cover 15% of the original tokens. This objective aims for seq2seq tasks whose predictions are often complete sentences or paragraphs.</p>
</li>
</ul>
<p>Both new objectives are defined in the same way as the original objective, i.e. Eq. <a href="#S2.E1">1</a>. The only difference is the number of spans and the span lengths.</p>
</section>
</section>
<section>
<h3>
2.2 Model Architecture</h3>
<p>GLM uses a single Transformer with several modifications to the architecture: (1) we rearrange the order of layer normalization and the residual connection, which has been shown critical for large-scale language models to avoid numerical errors <cite>Shoeybi et al. (<a href="#bib.bib39">2019</a>)</cite>; (2) we use a single linear layer for the output token prediction; (3) we replace ReLU activation functions with GeLUs <cite>Hendrycks and Gimpel (<a href="#bib.bib15">2016</a>)</cite>.</p>
<section>
<h4>
2.2.1 2D Positional Encoding</h4>
<p>One of the challenges of the autoregressive blank infilling task is how to encode the positional information. Transformers rely on positional encodings to inject the absolute and relative positions of the tokens.
We propose 2D positional encodings to address the challenge. Specifically, each token is encoded with two positional ids. The first positional id represents the position in the corrupted text <math></math>. For the masked spans, it is the position of the corresponding <math></math> token. The second positional id represents the intra-span position. For tokens in Part A, their second positional ids are <math></math>. For tokens in Part B, they range from 1 to the length of the span. The two positional ids are projected into two vectors via learnable embedding tables, which are both added to the input token embeddings.</p>
<p>Our encoding method ensures that the model is not aware of the length of the masked span when reconstructing them. It is an important difference as compared to other models. For example, XLNet <cite>Yang et al. (<a href="#bib.bib46">2019</a>)</cite> encodes the original position so that it can perceive the number of missing tokens, and SpanBERT <cite>Joshi et al. (<a href="#bib.bib16">2020</a>)</cite> replaces the span with multiple [MASK] tokens and keeps the length unchanged. Our design fits downstream tasks as usually the length of the generated text is unknown beforehand.</p>
<figure><img src="/html/2103.10360/assets/x3.png"/>
<figcaption>Figure 3: Formulation of the sentiment classification task as blank infilling with GLM.</figcaption>
</figure>
</section>
</section>
<section>
<h3>
2.3 Finetuning GLM</h3>
<p>Typically, for downstream NLU tasks, a linear classifier takes the representations of sequences or tokens produced by pretrained models as input and predicts the correct labels.
The practices are different from the generative pretraining task, leading to inconsistency between pretraining and finetuning.</p>
<p>Instead, we reformulate NLU classification tasks as generation tasks of blank infilling, following PET <cite>Schick and Schütze (<a href="#bib.bib35">2020a</a>)</cite>. Specifically, given a labeled example <math></math>, we convert the input text <math></math> to a cloze question <math></math> via a pattern containing a single mask token. The pattern is written in natural language to represent the semantics of the task. For example, a sentiment classification task can be formulated as “{SENTENCE}. It’s really <math></math>”. The candidate labels <math></math> are also mapped to answers to the cloze, called verbalizer <math></math>. In sentiment classification, the labels “positive” and “negative” are mapped to the words “good” and “bad”. The conditional probability of predicting <math></math> given <math></math> is</p>
<table>
<tbody><tr>
<td></td>
<td><math></math></td>
<td></td>
<td>(3)</td>
</tr></tbody>
</table>
<p>where <math></math> is the label set. Therefore the probability of the sentence being positive or negative is proportional to predicting “good” or “bad” in the blank. Then we finetune GLM with a cross-entropy loss (see <a href="#S2.F3">Figure 3</a>).</p>
<p>For text generation tasks, the given context constitutes the Part A of the input, with a mask token appended at the end. The model generates the text of Part B autoregressively. We can directly apply the pretrained GLM for unconditional generation, or finetune it on downstream conditional generation tasks.</p>
</section>
<section>
<h3>
2.4 Discussion and Analysis</h3>
<p>In this section, we discuss the differences between GLM and other pretraining models. We are mainly concerned with how they can be adapted to downstream blank infilling tasks.</p>
<p>Comparison with BERT <cite>Devlin et al. (<a href="#bib.bib9">2019</a>)</cite>.
As pointed out by <cite>Yang et al. (<a href="#bib.bib46">2019</a>)</cite>, BERT fails to capture the interdependencies of masked tokens due to the independence assumption of MLM. Another disadvantage of BERT is that it cannot fill in the blanks of multiple tokens properly. To infer the probability of an answer of length <math></math>, BERT needs to perform <math></math> consecutive predictions. If the length <math></math> is unknown, we may need to enumerate all possible lengths, since BERT needs to change the number of <math></math> tokens according to the length.</p>
<p>Comparison with XLNet <cite>Yang et al. (<a href="#bib.bib46">2019</a>)</cite>.
Both GLM and XLNet are pretrained with autoregressive objectives, but there are two differences between them. First, XLNet uses the original position encodings before corruption. During inference, we need to either know or enumerate the length of the answer, the same problem as BERT. Second, XLNet uses a two-stream self-attention mechanism, instead of the right-shift, to avoid the information leak within Transformer. It doubles the time cost of pretraining.</p>
<p>Comparison with T5 <cite>Raffel et al. (<a href="#bib.bib30">2020</a>)</cite>.
T5 proposes a similar blank infilling objective to pretrain an encoder-decoder Transformer.
T5 uses independent positional encodings for the encoder and decoder, and relies on multiple sentinel tokens to differentiate the masked spans. In downstream tasks, only one of the sentinel tokens is used, leading to a waste of model capacity and inconsistency between pretraining and finetuning. Moreover, T5 always predicts spans in a fixed left-to-right order. As a result, GLM can significantly outperform T5 on NLU and seq2seq tasks with fewer parameters and data, as stated in <a href="#S3.SS2">Sections 3.2</a> and <a href="#S3.SS3">3.3</a>.</p>
<p>Comparison with UniLM <cite>Dong et al. (<a href="#bib.bib11">2019</a>)</cite>.
UniLM combines different pretraining objectives under the autoencoding framework by changing the attention mask among bidirectional, unidirectional, and cross attention. However, UniLM always replaces masked spans with [MASK] tokens, which limits its ability to model the dependencies between the masked spans and their context. GLM feeds in the previous token and autoregressively generates the next token. Finetuning UniLM on downstream generation tasks also relies on masked language modeling, which is less efficient. UniLMv2 <cite>Bao et al. (<a href="#bib.bib2">2020</a>)</cite> adopts partially autoregressive modeling for generation tasks, along with the autoencoding objective for NLU tasks. Instead, GLM unifies NLU and generation tasks with autoregressive pretraining.</p>
<figure>
<figcaption>Table 1: Results on the SuperGLUE dev set.</figcaption>
<table>
<tr>
<td></td>
<td>Model</td>
<td>
 
ReCoRD
F1/Acc.
</td>
<td>
 
COPA
Acc.
</td>
<td>
 
WSC
Acc.
</td>
<td>
 
RTE
Acc.
</td>
<td>
 
BoolQ
Acc.
</td>
<td>
 
WiC
Acc.
</td>
<td>
 
CB
F1/Acc.
</td>
<td>
 
MultiRC
F1a/EM
</td>
<td>Avg</td>
</tr>
<tr>
<td>Pretrained on BookCorpus and Wikipedia</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>BERT<math></math>
</td>
<td>65.4 / 64.9</td>
<td>66.0</td>
<td>65.4</td>
<td>70.0</td>
<td>74.9</td>
<td>68.8</td>
<td>70.9 / 76.8</td>
<td>68.4 / 21.5</td>
<td>66.1</td>
</tr>
<tr>
<td></td>
<td>GLM<math></math>
</td>
<td>73.5 / 72.8</td>
<td>71.0</td>
<td>72.1</td>
<td>71.2</td>
<td>77.0</td>
<td>64.7</td>
<td>89.5 / 85.7</td>
<td>72.1 / 26.1</td>
<td>70.7</td>
</tr>
<tr>
<td></td>
<td>BERT<math></math>
</td>
<td>76.3 / 75.6</td>
<td>69.0</td>
<td>64.4</td>
<td>73.6</td>
<td>80.1</td>
<td>71.0</td>
<td>94.8 / 92.9</td>
<td>71.9 / 24.1</td>
<td>72.0</td>
</tr>
<tr>
<td></td>
<td>UniLM<math></math>
</td>
<td>80.0 / 79.1</td>
<td>72.0</td>
<td>65.4</td>
<td>76.5</td>
<td>80.5</td>
<td>69.7</td>
<td>91.0 / 91.1</td>
<td>77.2 / 38.2</td>
<td>74.1</td>
</tr>
<tr>
<td></td>
<td>GLM<math></math>
</td>
<td>81.7 / 81.1</td>
<td>76.0</td>
<td>81.7</td>
<td>74.0</td>
<td>82.1</td>
<td>68.5</td>
<td>96.1 / 94.6</td>
<td>77.1 / 36.3</td>
<td>77.0</td>
</tr>
<tr>
<td></td>
<td>GLM<math></math>
</td>
<td>80.2 / 79.6</td>
<td>77.0</td>
<td>78.8</td>
<td>76.2</td>
<td>79.8</td>
<td>63.6</td>
<td>97.3 / 96.4</td>
<td>74.6 / 32.1</td>
<td>75.7</td>
</tr>
<tr>
<td></td>
<td>GLM<math></math>
</td>
<td>80.7 / 80.2</td>
<td>77.0</td>
<td>79.8</td>
<td>79.1</td>
<td>80.8</td>
<td>70.4</td>
<td>94.6 / 93.7</td>
<td>76.9 / 36.1</td>
<td>76.8</td>
</tr>
<tr>
<td></td>
<td>GLM<math></math>
</td>
<td>81.5 / 80.9</td>
<td>80.0</td>
<td>81.7</td>
<td>79.4</td>
<td>81.9</td>
<td>69.0</td>
<td>93.2 / 96.4
</td>
<td>76.2 / 35.5</td>
<td>78.0</td>
</tr>
<tr>
<td></td>
<td>GLM<math></math>
</td>
<td>82.3 / 81.7</td>
<td>85.0</td>
<td>81.7</td>
<td>79.1</td>
<td>81.3</td>
<td>69.4</td>
<td>95.0 / 96.4
</td>
<td>
77.2 / 35.0</td>
<td>78.8</td>
</tr>
<tr>
<td>Pretrained on larger corpora</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>T5<math></math>
</td>
<td>76.2 / 75.4</td>
<td>73.0</td>
<td>79.8</td>
<td>78.3</td>
<td>80.8</td>
<td>67.9</td>
<td>94.8 / 92.9</td>
<td>76.4 / 40.0</td>
<td>76.0</td>
</tr>
<tr>
<td></td>
<td>T5<math></math>
</td>
<td>85.7 / 85.0</td>
<td>78.0</td>
<td>84.6</td>
<td>84.8</td>
<td>84.3</td>
<td>71.6</td>
<td>96.4 / 98.2</td>
<td>80.9 / 46.6</td>
<td>81.2</td>
</tr>
<tr>
<td></td>
<td>BART<math></math>
</td>
<td>88.3 / 87.8</td>
<td>60.0</td>
<td>65.4</td>
<td>84.5</td>
<td>84.3</td>
<td>69.0</td>
<td>90.5 / 92.9</td>
<td>81.8 / 48.0</td>
<td>76.0</td>
</tr>
<tr>
<td></td>
<td>RoBERTa<math></math>
</td>
<td>89.0 / 88.4</td>
<td>90.0</td>
<td>63.5</td>
<td>87.0</td>
<td>86.1</td>
<td>72.6</td>
<td>96.1 / 94.6</td>
<td>84.4 / 52.9</td>
<td>81.5</td>
</tr>
<tr>
<td></td>
<td>GLM<math></math>
</td>
<td>89.6 / 89.0</td>
<td>82.0</td>
<td>83.7</td>
<td>87.7</td>
<td>84.7</td>
<td>71.2</td>
<td>98.7 / 98.2</td>
<td>82.4 / 50.1</td>
<td>82.9</td>
</tr>
</table>
</figure>
</section>
</section>
<section>
<h2>
3 Experiments</h2>
<p>We now describe our pretraining setup and the evaluation of downstream tasks.</p>
<section>
<h3>
3.1 Pretraining Setup</h3>
<p>For a fair comparison with BERT <cite>Devlin et al. (<a href="#bib.bib9">2019</a>)</cite>, we use BooksCorpus <cite>Zhu et al. (<a href="#bib.bib50">2015</a>)</cite> and English Wikipedia as our pretraining data. We use the uncased wordpiece tokenizer of BERT with 30k vocabulary.
We train GLM<math></math> and GLM<math></math> with the same architectures as BERT<math></math> and BERT<math></math>, containing 110M and 340M parameters respectively.</p>
<p>For multi-task pretraining, we train two Large-sized models with a mixture of the blank infilling objective and the document-level or sentence-level objective, denoted as GLM<math></math> and GLM<math></math>. Additionally, we train two larger GLM models of 410M (30 layers, hidden size 1024, and 16 attention heads) and 515M (30 layers, hidden size 1152, and 18 attention heads) parameters with document-level multi-task pretraining, denoted as GLM<math></math> and GLM<math></math>.</p>
<p>To compare with SOTA models, we also train a Large-sized model with the same data, tokenization, and hyperparameters as RoBERTa <cite>Liu et al. (<a href="#bib.bib21">2019</a>)</cite>, denoted as GLM<math></math>.
Due to resource limitations, we only pretrain the model for 250,000 steps, which are half of RoBERTa and BART’s training steps and close to T5 in the number of trained tokens.
More experiment details can be found in <a href="#A1">Appendix A</a>.</p>
<figure>
<figcaption>Table 2: Results of abstractive summarization on the CNN/DailyMail and XSum test sets.</figcaption>
<table>
<tbody>
<tr>
<th>
 
Model
</th>
<td>CNN/DailyMail</td>
<td>XSum</td>
</tr>
<tr>
<td>RG-1</td>
<td>RG-2</td>
<td>RG-L</td>
<td>RG-1</td>
<td>RG-2</td>
<td>RG-L</td>
</tr>
<tr>
<td>BERTSumAbs <cite>Liu and Lapata (<a href="#bib.bib20">2019</a>)</cite>
</td>
<td>41.7</td>
<td>19.4</td>
<td>38.8</td>
<td>38.8</td>
<td>16.3</td>
<td>31.2</td>
</tr>
<tr>
<td>UniLMv2<math></math> <cite>Bao et al. (<a href="#bib.bib2">2020</a>)</cite>
</td>
<td>43.2</td>
<td>20.4</td>
<td>40.1</td>
<td>44.0</td>
<td>21.1</td>
<td>36.1</td>
</tr>
<tr>
<td>T5<math></math> <cite>Raffel et al. (<a href="#bib.bib30">2020</a>)</cite>
</td>
<td>42.5</td>
<td>20.7</td>
<td>39.8</td>
<td>40.9</td>
<td>17.3</td>
<td>33.0</td>
</tr>
<tr>
<td>BART<math></math> <cite>Lewis et al. (<a href="#bib.bib18">2019</a>)</cite>
</td>
<td>44.2</td>
<td>21.3</td>
<td>40.9</td>
<td>45.1</td>
<td>22.3</td>
<td>37.3</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>43.8</td>
<td>21.0</td>
<td>40.5</td>
<td>45.5</td>
<td>23.5</td>
<td>37.3</td>
</tr>
</tbody>
</table>
</figure>
</section>
<section>
<h3>
3.2 SuperGLUE</h3>
<p>To evaluate our pretrained GLM models, we conduct experiments on the SuperGLUE benchmark <cite>Wang et al. (<a href="#bib.bib43">2019</a>)</cite> and report the standard metrics. SuperGLUE consists of 8 challenging NLU tasks.
We reformulate the classification tasks as blank infilling with human-crafted cloze questions, following PET <cite>Schick and Schütze (<a href="#bib.bib36">2020b</a>)</cite>. Then we finetune the pretrained GLM models on each task as described in <a href="#S2.SS3">Section 2.3</a>. The cloze questions and other details can be found in <a href="#A2.SS1">Section B.1</a>.</p>
<p>For a fair comparison with GLM<math></math> and GLM<math></math>, we choose BERT<math></math> and BERT<math></math> as our baselines, which are pretrained on the same corpus and for a similar amount of time. We report the performance of standard finetuning (i.e. classification on the [CLS] token representation). The performance of BERT with cloze questions is reported in <a href="#S3.SS4">Section 3.4</a>. To compare with GLM<math></math>, we choose T5, BART<math></math>, and RoBERTa<math></math> as our baselines. T5 has no direct match in the number of parameters for BERT<math></math>, so we present the results of both T5<math></math> (220M parameters) and T5<math></math> (770M parameters). All the other baselines are of similar size to BERT<math></math>.</p>
<p><a href="#S2.T1">Table 1</a> shows the results. With the same amount of training data, GLM consistently outperforms BERT on most tasks with either base or large architecture. The only exception is WiC (word sense disambiguation). On average, GLM<math></math> scores 4.6% higher than BERT<math></math>, and GLM<math></math> scores 5.0% higher than BERT<math></math>. It clearly demonstrates the advantage of our method in NLU tasks. In the setting of RoBERTa<math></math>, GLM<math></math> can still achieve improvements over the baselines, but with a smaller margin. Specifically, GLM<math></math> outperforms T5<math></math> but is only half its size. We also find that BART does not perform well on the challenging SuperGLUE benchmark. We conjecture this can be attributed to the low parameter efficiency of the encoder-decoder architecture and the denoising sequence-to-sequence objective.</p>
</section>
<section>
<h3>
3.3 Multi-Task Pretraining</h3>
<p>Then we evaluate the GLM’s performance in a multi-task setting (<a href="#S2.SS1">Section 2.1</a>). Within one training batch, we sample short spans and longer spans (document-level or sentence-level) with equal chances. We evaluate the multi-task model for NLU, seq2seq, blank infilling, and zero-shot language modeling.</p>
<p>SuperGLUE.
For NLU tasks, we evaluate models on the SuperGLUE benchmark. The results are also shown in <a href="#S2.T1">Table 1</a>. We observe that with multi-task pretraining, GLM<math></math> and GLM<math></math> perform slightly worse than GLM<math></math>, but still outperform BERT<math></math> and UniLM<math></math>. Among multi-task models, GLM<math></math> outperforms GLM<math></math> by 1.1% on average. Increasing GLM<math></math>’s parameters to 410M (1.25<math></math>BERT<math></math>) leads to better performance than GLM<math></math>. GLM with 515M parameters (1.5<math></math>BERT<math></math>) can perform even better.</p>
<figure>
<figcaption>Table 3: Results on Gigaword summarization.</figcaption>
<table>
<tr>
<td>Model</td>
<td>RG-1</td>
<td>RG-2</td>
<td>RG-L</td>
</tr>
<tr>
<td>MASS</td>
<td>37.7</td>
<td>18.5</td>
<td>34.9</td>
</tr>
<tr>
<td>UniLM<math></math>
</td>
<td>38.5</td>
<td>19.5</td>
<td>35.8</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>38.6</td>
<td>19.7</td>
<td>36.0</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>38.5</td>
<td>19.4</td>
<td>35.8</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>38.9</td>
<td>20.0</td>
<td>36.3</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>38.9</td>
<td>20.0</td>
<td>36.2</td>
</tr>
</table>
<figcaption>Table 4: Results on SQuAD question generation.</figcaption>
<table>
<tr>
<td>Model</td>
<td>BLEU-4</td>
<td>MTR</td>
<td>RG-L</td>
</tr>
<tr>
<td>SemQG</td>
<td>18.4</td>
<td>22.7</td>
<td>46.7</td>
</tr>
<tr>
<td>UniLM<math></math>
</td>
<td>22.1</td>
<td>25.1</td>
<td>51.1</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>22.4</td>
<td>25.2</td>
<td>50.4</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>22.3</td>
<td>25.0</td>
<td>50.2</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>22.6</td>
<td>25.4</td>
<td>50.4</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>22.9</td>
<td>25.6</td>
<td>50.5</td>
</tr>
</table>
<figcaption>Table 5: BLEU scores on Yahoo text infilling. <sup>†</sup> indicates the results from <cite>Shen et al. (<a href="#bib.bib38">2020</a>)</cite>.</figcaption>
<table>
<tr>
<td>Mask ratio</td>
<td>10%</td>
<td>20%</td>
<td>30%</td>
<td>40%</td>
<td>50%</td>
</tr>
<tr>
<td>BERT<sup>†</sup>
</td>
<td>82.8</td>
<td>66.3</td>
<td>50.3</td>
<td>37.4</td>
<td>26.2</td>
</tr>
<tr>
<td>BLM<sup>†</sup>
</td>
<td>86.5</td>
<td>73.2</td>
<td>59.6</td>
<td>46.8</td>
<td>34.8</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>87.8</td>
<td>76.7</td>
<td>64.2</td>
<td>48.9</td>
<td>38.7</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>87.5</td>
<td>76.0</td>
<td>63.2</td>
<td>47.9</td>
<td>37.6</td>
</tr>
</table>
</figure>
<p>Sequence-to-Sequence.
Considering the available baseline results, we use the Gigaword dataset <cite>Rush et al. (<a href="#bib.bib34">2015</a>)</cite> for abstractive summarization and the SQuAD 1.1 dataset <cite>Rajpurkar et al. (<a href="#bib.bib32">2016</a>)</cite> for question generation <cite>Du et al. (<a href="#bib.bib12">2017</a>)</cite> as the benchmarks for models pretrained on BookCorpus and Wikipedia. Additionally, we use the CNN/DailyMail <cite>See et al. (<a href="#bib.bib37">2017</a>)</cite> and XSum <cite>Narayan et al. (<a href="#bib.bib23">2018</a>)</cite> datasets for abstractive summarization as the benchmarks for models pretrained on larger corpora.</p>
<p>The results for models trained on BookCorpus and Wikipedia are shown in <a href="#S3.T5">Tables 5</a> and <a href="#S3.T5">5</a>. We observe that GLM<math></math> can achieve performance matching the other pretraining models on the two generation tasks.
GLM<math></math> can perform better than GLM<math></math>, while
GLM<math></math> performs slightly worse than GLM<math></math>. This indicates that the document-level objective, which teaches the model to extend the given contexts, is less helpful to conditional generation, which aims to extract useful information from the context. Increasing GLM<math></math>’s parameters to 410M leads to the best performance on both tasks.
The results for models trained on larger corpora are shown in <a href="#S3.T2">Table 2</a>. GLM<math></math> can achieve performance matching the seq2seq BART model, and outperform T5 and UniLMv2.</p>
<p>Text Infilling.
Text infilling is the task of predicting missing spans of text which are consistent with the surrounding context <cite>Zhu et al. (<a href="#bib.bib49">2019</a>); Donahue et al. (<a href="#bib.bib10">2020</a>); Shen et al. (<a href="#bib.bib38">2020</a>)</cite>. GLM is trained with an autoregressive blank infilling objective, thus can straightforwardly solve this task. We evaluate GLM on the Yahoo Answers dataset <cite>Yang et al. (<a href="#bib.bib47">2017</a>)</cite> and compare it with Blank Language Model (BLM) <cite>Shen et al. (<a href="#bib.bib38">2020</a>)</cite>, which is a specifically designed model for text infilling. From the results in <a href="#S3.T5">Table 5</a>, GLM outperforms previous methods by large margins (1.3 to 3.9 BLEU) and achieves the state-of-the-art result on this dataset. We notice that GLM<math></math> slightly underperforms GLM<math></math>, which is consistent with our observations in the seq2seq experiments.</p>
<p>Language Modeling.
Most language modeling datasets such as WikiText103 are constructed from Wikipedia documents, which our pretraining dataset already contains.
Therefore, we evaluate the language modeling perplexity on a held-out test set of our pretraining dataset, which contains about 20M tokens, denoted as BookWiki. We also evaluate GLM on the LAMBADA dataset <cite>Paperno et al. (<a href="#bib.bib25">2016</a>)</cite>, which tests the ability of systems to model long-range dependencies in text. The task is to predict the final word of a passage. As the baseline, we train a GPT<math></math> model <cite>Radford et al. (<a href="#bib.bib29">2018b</a>); Brown et al. (<a href="#bib.bib4">2020</a>)</cite> with the same data and tokenization as GLM<math></math>.</p>
<p>The results are shown in <a href="#S3.F4">Figure 4</a>. All the models are evaluated in the zero-shot setting. Since GLM learns the bidirectional attention, we also evaluate GLM under the setting in which the contexts are encoded with bidirectional attention. Without generative objective during pretraining, GLM<math></math> cannot complete the language modeling tasks, with perplexity larger than 100. With the same amount of parameters, GLM<math></math> performs worse than GPT<math></math>. This is expected since GLM<math></math> also optimizes the blank infilling objective. Increasing the model’s parameters to 410M (1.25<math></math> of GPT<math></math>) leads to a performance close to GPT<math></math>. GLM<math></math> (1.5<math></math> of GPT<math></math>) can further outperform GPT<math></math>. With the same amount of parameters, encoding the context with bidirectional attention can improve the performance of language modeling. Under this setting, GLM<math></math> outperforms GPT<math></math>. This is the advantage of GLM over unidirectional GPT. We also study the contribution of 2D positional encoding to long text generation. We find that removing the 2D positional encoding leads to lower accuracy and higher perplexity in language modeling.</p>
<figure><img src="/html/2103.10360/assets/x4.png"/>
<figcaption>Figure 4: Zero-shot language modeling results.</figcaption>
</figure>
<figure>
<figcaption>Table 6: Ablation study on the SuperGLUE dev set. (T5 <math></math> GLM – shuffle spans + sentinel tokens.)</figcaption>
<table>
<tr>
<td>Model</td>
<td>
 
ReCoRD
F1/Acc.
</td>
<td>
 
COPA
Acc.
</td>
<td>
 
WSC
Acc.
</td>
<td>
 
RTE
Acc.
</td>
<td>
 
BoolQ
Acc.
</td>
<td>
 
WiC
Acc.
</td>
<td>
 
CB
F1/Acc.
</td>
<td>
 
MultiRC
F1a/EM
</td>
<td>Avg</td>
</tr>
<tr>
<td>BERT<math></math>
</td>
<td>76.3 / 75.6</td>
<td>69.0</td>
<td>64.4</td>
<td>73.6</td>
<td>80.1</td>
<td>71.0</td>
<td>94.8 / 92.9</td>
<td>71.9 / 24.1</td>
<td>72.0</td>
</tr>
<tr>
<td>BERT<math></math> (reproduced)</td>
<td>82.1 / 81.5</td>
<td>63.0</td>
<td>63.5</td>
<td>72.2</td>
<td>80.8</td>
<td>68.7</td>
<td>80.9 / 85.7</td>
<td>77.0 / 35.2</td>
<td>71.2</td>
</tr>
<tr>
<td>BERT<math></math> (cloze)</td>
<td>70.0 / 69.4</td>
<td>80.0</td>
<td>76.0</td>
<td>72.6</td>
<td>78.1</td>
<td>70.5</td>
<td>93.5 / 91.1</td>
<td>70.0 / 23.1</td>
<td>73.2</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>81.7 / 81.1</td>
<td>76.0</td>
<td>81.7</td>
<td>74.0</td>
<td>82.1</td>
<td>68.5</td>
<td>96.1 / 94.6</td>
<td>77.1 / 36.3</td>
<td>77.0</td>
</tr>
<tr>
<td>     – cloze finetune</td>
<td>81.3 / 80.6</td>
<td>62.0</td>
<td>63.5</td>
<td>66.8</td>
<td>80.5</td>
<td>65.0</td>
<td>89.2 / 91.1</td>
<td>72.3 / 27.9</td>
<td>70.0</td>
</tr>
<tr>
<td>     – shuffle spans</td>
<td>82.0 / 81.4</td>
<td>61.0</td>
<td>79.8</td>
<td>54.5</td>
<td>65.8</td>
<td>56.3</td>
<td>90.5 / 92.9</td>
<td>76.7 / 37.6</td>
<td>68.5</td>
</tr>
<tr>
<td>     + sentinel tokens</td>
<td>81.8 / 81.3</td>
<td>69.0</td>
<td>78.8</td>
<td>77.3</td>
<td>81.2</td>
<td>68.0</td>
<td>93.7 / 94.6</td>
<td>77.5 / 37.7</td>
<td>76.0</td>
</tr>
</table>
</figure>
<p>Summary.
Above all, we conclude that GLM effectively shares model parameters across natural language understanding and generation tasks, achieving better performance than a standalone BERT, encoder-decoder, or GPT model.</p>
</section>
<section>
<h3>
3.4 Ablation Study</h3>
<p><a href="#S3.T6">Table 6</a> shows our ablation analysis for GLM. First, to provide an apple-to-apple comparison with BERT, we train a BERT<math></math> model with our implementation, data, and hyperparameters (row 2). The performance is slightly worse than the official BERT<math></math> and significantly worse than GLM<math></math>. It confirms the superiority of GLM over Masked LM pretraining on NLU tasks. Second,
we show the SuperGLUE performance of GLM finetuned as sequence classifiers (row 5) and BERT with cloze-style finetuning (row 3). Compared to BERT with cloze-style finetuning, GLM benefits from the autoregressive pretraining. Especially on ReCoRD and WSC, where the verbalizer consists of multiple tokens, GLM consistently outperforms BERT. This demonstrates GLM’s advantage in handling variable-length blank. Another observation is that the cloze formulation is critical for GLM’s performance on NLU tasks. For the large model, cloze-style finetuning can improve the performance by 7 points. Finally, we compare GLM variants with different pretraining designs to understand their importance. Row 6 shows that removing the span shuffling (always predicting the masked spans from left to right) leads to a severe performance drop on SuperGLUE. Row 7 uses different sentinel tokens instead of a single <math></math> token to represent different masked spans. The model performs worse than the standard GLM. We hypothesize that it wastes some modeling capacity to learn the different sentinel tokens which are not used in downstream tasks with only one blank. In <a href="#S3.F4">Figure 4</a>, we show that removing the second dimension of 2D positional encoding hurts the performance of long text generation.</p>
<p>We note that T5 is pretrained with a similar blank infilling objective. GLM differs in three aspects: (1) GLM consists of a single encoder, (2) GLM shuffles the masked spans, and (3) GLM uses a single [MASK] instead of multiple sentinel tokens. While we cannot directly compare GLM with T5 due to the differences in training data and the number of parameters, the results in <a href="#S2.T1">Tables 1</a> and <a href="#S3.T6">6</a> have demonstrated the advantage of GLM.</p>
</section>
</section>
<section>
<h2>
4 Related Work</h2>
<p>Pretrained Language Models. Pretraining large-scale language models significantly improves the performance of downstream tasks. There are three types of pretrained models. First, autoencoding models learn a bidirectional contextualized encoder for natural language understanding via denoising objectives <cite>Devlin et al. (<a href="#bib.bib9">2019</a>); Joshi et al. (<a href="#bib.bib16">2020</a>); Yang et al. (<a href="#bib.bib46">2019</a>); Liu et al. (<a href="#bib.bib21">2019</a>); Lan et al. (<a href="#bib.bib17">2020</a>); Clark et al. (<a href="#bib.bib6">2020</a>)</cite>.
Second, autoregressive models are trained with a left-to-right language modeling objective <cite>Radford et al. (<a href="#bib.bib28">2018a</a>, <a href="#bib.bib29">b</a>); Brown et al. (<a href="#bib.bib4">2020</a>)</cite>.
Third, encoder-decoder models are pretrained for sequence-to-sequence tasks <cite>Song et al. (<a href="#bib.bib41">2019</a>); Lewis et al. (<a href="#bib.bib18">2019</a>); Bi et al. (<a href="#bib.bib3">2020</a>); Zhang et al. (<a href="#bib.bib48">2020</a>)</cite>.</p>
<p>Among encoder-decoder models, BART <cite>Lewis et al. (<a href="#bib.bib18">2019</a>)</cite> conducts NLU tasks by feeding the same input into the encoder and decoder, and taking the final hidden states of the decoder. Instead, T5 <cite>Raffel et al. (<a href="#bib.bib30">2020</a>)</cite> formulates most language tasks in the text-to-text framework. However, both models require more parameters to outperform autoencoding models such as RoBERTa <cite>Liu et al. (<a href="#bib.bib21">2019</a>)</cite>.
UniLM <cite>Dong et al. (<a href="#bib.bib11">2019</a>); Bao et al. (<a href="#bib.bib2">2020</a>)</cite> unifies three pretraining models under the masked language modeling objective with different attention masks.</p>
<p>NLU as Generation. Previously, pretrained language models complete classification tasks for NLU with linear classifiers on the learned representations. GPT-2 <cite>Radford et al. (<a href="#bib.bib29">2018b</a>)</cite> and GPT-3 <cite>Brown et al. (<a href="#bib.bib4">2020</a>)</cite> show that generative language models can complete NLU tasks such as question answering by directly predicting the correct answers without finetuning, given task instructions or a few labeled examples. However, generative models require much more parameters to work due to the limit of unidirectional attention. Recently, PET <cite>Schick and Schütze (<a href="#bib.bib35">2020a</a>, <a href="#bib.bib36">b</a>)</cite> proposes to reformulate input examples as cloze questions with patterns similar to the pretraining corpus in the few-shot setting. It has been shown that combined with gradient-based finetuning, PET can achieve better performance in the few-shot setting than GPT-3 while requiring only 0.1% of its parameters. Similarly, <cite>Athiwaratkun et al. (<a href="#bib.bib1">2020</a>)</cite> and <cite>Paolini et al. (<a href="#bib.bib24">2020</a>)</cite> convert structured prediction tasks, such as sequence tagging and relation extraction, to sequence generation tasks.</p>
<p>Blank Language Modeling. <cite>Donahue et al. (<a href="#bib.bib10">2020</a>)</cite> and <cite>Shen et al. (<a href="#bib.bib38">2020</a>)</cite> also study blanking infilling models. Different from their work, we pre-train language models with blank infilling objectives and evaluate their performance in downstream NLU and generation tasks.</p>
</section>
<section>
<h2>
5 Conclusions</h2>
<p>GLM is a general pretraining framework for natural language understanding and generation. We show that the NLU tasks can be formulated as conditional generation tasks, and therefore solvable by autoregressive models. GLM unifies the pretraining objectives for different tasks as autoregressive blank infilling, with mixed attention masks and the novel 2D position encodings. Empirically we show that GLM outperforms previous methods for NLU tasks and can effectively share parameters for different tasks.</p>
</section>
<section>
<h2>Acknowledgements</h2>
<p>The work is supported by the NSFC for Distinguished Young Scholar(61825602), and Beijing Academy of Artificial Intelligence (BAAI).</p>
</section>
<section>
<h2>References</h2>
<ul>
<li>
Athiwaratkun et al. (2020)
Ben Athiwaratkun, Cicero dos Santos, Jason Krone, and Bing Xiang. 2020.
<a href="https://doi.org/10.18653/v1/2020.emnlp-main.27">Augmented
natural language for generative sequence labeling</a>.
In <em>Proceedings of the 2020 Conference on Empirical Methods in
Natural Language Processing (EMNLP)</em>, pages 375–385.
</li>
<li>
Bao et al. (2020)
Hangbo Bao, Li Dong, Furu Wei, Wenhui Wang, Nan Yang, Xiaodong Liu, Yu Wang,
Jianfeng Gao, Songhao Piao, Ming Zhou, and Hsiao-Wuen Hon. 2020.
<a href="http://arxiv.org/abs/2002.12804">Unilmv2: Pseudo-masked
language models for unified language model pre-training</a>.
In <em>ICML 2020</em>, volume 119, pages 642–652.
</li>
<li>
Bi et al. (2020)
Bin Bi, Chenliang Li, Chen Wu, Ming Yan, Wei Wang, Songfang Huang, Fei Huang,
and Luo Si. 2020.
<a href="https://doi.org/10.18653/v1/2020.emnlp-main.700">PALM:
Pre-training an Autoencoding&amp;Autoregressive Language Model for
Context-conditioned Generation</a>.
In <em>EMNLP 2020</em>, pages 8681–8691.
</li>
<li>
Brown et al. (2020)
Tom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan,
Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda
Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom
Henighan, Rewon Child, Aditya Ramesh, Daniel M. Ziegler, Jeffrey Wu, Clemens
Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott
Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec
Radford, Ilya Sutskever, and Dario Amodei. 2020.
<a href="https://proceedings.neurips.cc/paper/2020/hash/1457c0d6bfcb4967418bfb8ac142f64a-Abstract.html">Language Models are Few-Shot Learners</a>.
In <em>NeurIPS 2020</em>.
</li>
<li>
Cer et al. (2017)
Daniel Cer, Mona Diab, Eneko Agirre, Iñigo Lopez-Gazpio, and Lucia
Specia. 2017.
<a href="https://aclanthology.org/S17-2001">SemEval-2017 Task
1: Semantic Textual Similarity Multilingual and Crosslingual Focused
Evaluation</a>.
In <em>Proceedings of the 11th International Workshop on
Semantic Evaluation (SemEval-2017)</em>, pages 1–14.
</li>
<li>
Clark et al. (2020)
Kevin Clark, Minh-Thang Luong, Quoc V. Le, and Christopher D. Manning. 2020.
<a href="https://openreview.net/forum?id=r1xMH1BtvB">ELECTRA:
Pre-training Text Encoders as Discriminators Rather Than
Generators</a>.
In <em>ICLR 2020</em>.
</li>
<li>
Dagan et al. (2005)
Ido Dagan, Oren Glickman, and Bernardo Magnini. 2005.
<a href="https://doi.org/10.1007/11736790_9">The pascal recognising
textual entailment challenge</a>.
In <em>Machine Learning Challenges Workshop</em>, pages 177–190.
Springer.
</li>
<li>
Denkowski and Lavie (2014)
Michael Denkowski and Alon Lavie. 2014.
<a href="https://www.aclweb.org/anthology/W14-3348">Meteor
Universal: Language Specific Translation Evaluation for Any Target
Language</a>.
In <em>Proceedings of the Ninth Workshop on Statistical
Machine Translation</em>, pages 376–380.
</li>
<li>
Devlin et al. (2019)
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019.
<a href="https://aclanthology.org/N19-1423">BERT: Pre-training
of Deep Bidirectional Transformers for Language Understanding</a>.
In <em>NAACL 2019</em>, pages 4171–4186.
</li>
<li>
Donahue et al. (2020)
Chris Donahue, Mina Lee, and Percy Liang. 2020.
<a href="https://doi.org/10.18653/v1/2020.acl-main.225">Enabling
language models to fill in the blanks</a>.
pages 2492–2501.
</li>
<li>
Dong et al. (2019)
Li Dong, Nan Yang, Wenhui Wang, Furu Wei, Xiaodong Liu, Yu Wang, Jianfeng Gao,
Ming Zhou, and Hsiao-Wuen Hon. 2019.
<a href="https://proceedings.neurips.cc/paper/2019/file/c20bb2d9a50d5ac1f713f8b34d9aac5a-Paper.pdf">Unified language model pre-training for natural language understanding and
generation</a>.
In <em>NeurIPS 2019</em>, pages 13042–13054.
</li>
<li>
Du et al. (2017)
Xinya Du, Junru Shao, and Claire Cardie. 2017.
<a href="https://doi.org/10.18653/v1/P17-1123">Learning to Ask:
Neural Question Generation for Reading Comprehension</a>.
In <em>ACL 2017</em>, pages 1342–1352.
</li>
<li>
Gokaslan and Cohen (2019)
Aaron Gokaslan and Vanya Cohen. 2019.
Openwebtext corpus.
<a href="http://Skylion007.github.io/OpenWebTextCorpus">http://Skylion007.github.io/OpenWebTextCorpus</a>.
</li>
<li>
He et al. (2021)
Pengcheng He, Xiaodong Liu, Jianfeng Gao, and Weizhu Chen. 2021.
<a href="http://arxiv.org/abs/2006.03654">Deberta: Decoding-enhanced
bert with disentangled attention</a>.
<em>ArXiv</em>, abs/2006.03654.
</li>
<li>
Hendrycks and Gimpel (2016)
Dan Hendrycks and Kevin Gimpel. 2016.
<a href="http://arxiv.org/abs/1606.08415">Bridging nonlinearities and
stochastic regularizers with gaussian error linear units</a>.
<em>CoRR</em>, abs/1606.08415.
</li>
<li>
Joshi et al. (2020)
Mandar Joshi, Danqi Chen, Yinhan Liu, Daniel S. Weld, Luke Zettlemoyer, and
Omer Levy. 2020.
<a href="https://transacl.org/ojs/index.php/tacl/article/view/1853">SpanBERT: Improving Pre-training by Representing and
Predicting Spans</a>.
<em>Trans. Assoc. Comput. Linguistics</em>, 8:64–77.
</li>
<li>
Lan et al. (2020)
Zhenzhong Lan, Mingda Chen, Sebastian Goodman, Kevin Gimpel, Piyush Sharma, and
Radu Soricut. 2020.
<a href="https://openreview.net/forum?id=H1eA7AEtvS">ALBERT: A
Lite BERT for Self-supervised Learning of Language
Representations</a>.
In <em>ICLR 2020</em>.
</li>
<li>
Lewis et al. (2019)
Mike Lewis, Yinhan Liu, Naman Goyal, Marjan Ghazvininejad, Abdelrahman Mohamed,
Omer Levy, Ves Stoyanov, and Luke Zettlemoyer. 2019.
<a href="https://doi.org/10.18653/v1/2020.acl-main.703">BART:
Denoising Sequence-to-Sequence Pre-training for Natural Language
Generation, Translation, and Comprehension</a>.
In <em>ACL 2020</em>, pages 7871–7880.
</li>
<li>
Lin (2004)
Chin-Yew Lin. 2004.
<a href="https://www.aclweb.org/anthology/W04-1013">ROUGE: A
Package for Automatic Evaluation of Summaries</a>.
pages 74–81.
</li>
<li>
Liu and Lapata (2019)
Yang Liu and Mirella Lapata. 2019.
<a href="https://www.aclweb.org/anthology/D19-1387">Text
Summarization with Pretrained Encoders</a>.
In <em>EMNLP 2019</em>, pages 3730–3740.
</li>
<li>
Liu et al. (2019)
Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer
Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019.
<a href="http://arxiv.org/abs/1907.11692">Roberta: A robustly
optimized BERT pretraining approach</a>.
<em>CoRR</em>, abs/1907.11692.
</li>
<li>
Mackenzie et al. (2020)
Joel Mackenzie, Rodger Benham, Matthias Petri, Johanne R. Trippas, J. Shane
Culpepper, and Alistair Moffat. 2020.
<a href="https://dl.acm.org/doi/10.1145/3340531.3412762">CC-News-En: A Large English News Corpus</a>.
In <em>CIKM 2020</em>, pages 3077–3084.
</li>
<li>
Narayan et al. (2018)
Shashi Narayan, Shay B. Cohen, and Mirella Lapata. 2018.
<a href="https://aclanthology.org/D18-1206">Don’t Give Me the
Details, Just the Summary! Topic-Aware Convolutional Neural
Networks for Extreme Summarization</a>.
In <em>EMNLP 2018</em>, pages 1797–1807.
</li>
<li>
Paolini et al. (2020)
Giovanni Paolini, Ben Athiwaratkun, Jason Krone, Jie Ma, Alessandro Achille,
Rishita Anubhai, Cicero Nogueira dos Santos, Bing Xiang, and Stefano Soatto.
2020.
<a href="https://openreview.net/forum?id=US-TP-xnXI">Structured
Prediction as Translation between Augmented Natural Languages</a>.
</li>
<li>
Paperno et al. (2016)
Denis Paperno, Germán Kruszewski, Angeliki Lazaridou, Quan Ngoc Pham,
Raffaella Bernardi, Sandro Pezzelle, Marco Baroni, Gemma Boleda, and Raquel
Fernández. 2016.
<a href="https://doi.org/10.18653/v1/p16-1144">The LAMBADA
dataset: Word prediction requiring a broad discourse context</a>.
In <em>ACL 2016</em>.
</li>
<li>
Papineni et al. (2002)
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. 2002.
<a href="https://www.aclweb.org/anthology/P02-1040">Bleu: A Method
for Automatic Evaluation of Machine Translation</a>.
In <em>ACL 2002</em>, pages 311–318.
</li>
<li>
Pereyra et al. (2017)
Gabriel Pereyra, George Tucker, Jan Chorowski, Lukasz Kaiser, and Geoffrey E.
Hinton. 2017.
<a href="https://openreview.net/forum?id=HyhbYrGYe">Regularizing
neural networks by penalizing confident output distributions</a>.
In <em>5th International Conference on Learning Representations,
ICLR 2017, Toulon, France, April 24-26, 2017, Workshop Track Proceedings</em>.
</li>
<li>
Radford et al. (2018a)
Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever.
2018a.
<a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">Improving Language Understanding by Generative Pre-Training</a>.
</li>
<li>
Radford et al. (2018b)
Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, and Ilya
Sutskever. 2018b.
<a href="https://d4mucfpksywv.cloudfront.net/better-language-models/language-models.pdf">Language models are unsupervised multitask learners</a>.
</li>
<li>
Raffel et al. (2020)
Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael
Matena, Yanqi Zhou, Wei Li, and Peter J. Liu. 2020.
<a href="http://arxiv.org/abs/1910.10683">Exploring the Limits of
Transfer Learning with a Unified Text-to-Text Transformer</a>.
<em>J. Mach. Learn. Res.</em>, 21:140:1–140:67.
</li>
<li>
Rajpurkar et al. (2018)
Pranav Rajpurkar, Robin Jia, and Percy Liang. 2018.
<a href="https://aclanthology.org/P18-2124">Know What You Don’t
Know: Unanswerable Questions for SQuAD</a>.
In <em>ACL 2018</em>, pages 784–789.
</li>
<li>
Rajpurkar et al. (2016)
Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. 2016.
<a href="https://doi.org/10.18653/v1/d16-1264">Squad: 100, 000+
questions for machine comprehension of text</a>.
In <em>EMNLP 2016</em>, pages 2383–2392.
</li>
<li>
Rasley et al. (2020)
Jeff Rasley, Samyam Rajbhandari, Olatunji Ruwase, and Yuxiong He. 2020.
<a href="https://doi.org/10.1145/3394486.3406703">Deepspeed: System
optimizations enable training deep learning models with over 100 billion
parameters</a>.
In <em>KDD 2020</em>, pages 3505–3506.
</li>
<li>
Rush et al. (2015)
Alexander M. Rush, Sumit Chopra, and Jason Weston. 2015.
<a href="https://aclanthology.org/D15-1044">A neural attention model
for abstractive sentence summarization</a>.
In <em>EMNLP 2015</em>, pages 379–389.
</li>
<li>
Schick and Schütze (2020a)
Timo Schick and Hinrich Schütze. 2020a.
<a href="https://aclanthology.org/2021.eacl-main.20/">Exploiting
Cloze Questions for Few Shot Text Classification and Natural
Language Inference</a>.
pages 255–269.
</li>
<li>
Schick and Schütze (2020b)
Timo Schick and Hinrich Schütze. 2020b.
<a href="https://doi.org/10.18653/v1/2021.naacl-main.185">It’s Not
Just Size That Matters: Small Language Models Are Also Few-Shot
Learners</a>.
pages 2339–2352.
</li>
<li>
See et al. (2017)
Abigail See, Peter J. Liu, and Christopher D. Manning. 2017.
<a href="https://doi.org/10.18653/v1/P17-1099">Get To The Point:
Summarization with Pointer-Generator Networks</a>.
In <em>ACL 2017</em>, pages 1073–1083.
</li>
<li>
Shen et al. (2020)
Tianxiao Shen, Victor Quach, Regina Barzilay, and Tommi S. Jaakkola. 2020.
<a href="https://doi.org/10.18653/v1/2020.emnlp-main.420">Blank
language models</a>.
pages 5186–5198.
</li>
<li>
Shoeybi et al. (2019)
Mohammad Shoeybi, Mostofa Patwary, Raul Puri, Patrick LeGresley, Jared Casper,
and Bryan Catanzaro. 2019.
<a href="http://arxiv.org/abs/1909.08053">Megatron-lm: Training
multi-billion parameter language models using model parallelism</a>.
<em>CoRR</em>, abs/1909.08053.
</li>
<li>
Socher et al. (2013)
Richard Socher, Alex Perelygin, Jean Wu, Jason Chuang, Christopher D. Manning,
Andrew Ng, and Christopher Potts. 2013.
<a href="https://aclanthology.org/D13-1170">Recursive Deep Models
for Semantic Compositionality Over a Sentiment Treebank</a>.
In <em>EMNLP 2013</em>, pages 1631–1642.
</li>
<li>
Song et al. (2019)
Kaitao Song, Xu Tan, Tao Qin, Jianfeng Lu, and Tie-Yan Liu. 2019.
<a href="http://proceedings.mlr.press/v97/song19d.html">MASS:
Masked Sequence to Sequence Pre-training for Language
Generation</a>.
In <em>ICML 2019</em>, volume 97, pages 5926–5936.
</li>
<li>
Trinh and Le (2019)
Trieu H. Trinh and Quoc V. Le. 2019.
<a href="http://arxiv.org/abs/1806.02847">A Simple Method for
Commonsense Reasoning</a>.
<em>arXiv:1806.02847 [cs]</em>.
</li>
<li>
Wang et al. (2019)
Alex Wang, Yada Pruksachatkun, Nikita Nangia, Amanpreet Singh, Julian Michael,
Felix Hill, Omer Levy, and Samuel R. Bowman. 2019.
<a href="https://proceedings.neurips.cc/paper/2019/hash/4496bf24afe7fab6f046bf4923da8de6-Abstract.html">SuperGLUE: A Stickier Benchmark for General-Purpose Language
Understanding Systems</a>.
In <em>NeurIPS 2019</em>, pages 3261–3275.
</li>
<li>
Wang et al. (2018)
Alex Wang, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel
Bowman. 2018.
<a href="https://openreview.net/forum?id=rJ4km2R5t7">GLUE: A
Multi-Task Benchmark and Analysis Platform for Natural Language
Understanding</a>.
In <em>ICLR 2019</em>, pages 353–355.
</li>
<li>
Williams et al. (2018)
Adina Williams, Nikita Nangia, and Samuel Bowman. 2018.
<a href="https://doi.org/10.18653/v1/n18-1101">A Broad-Coverage
Challenge Corpus for Sentence Understanding through Inference</a>.
In <em>NAACL 2018</em>, pages 1112–1122.
</li>
<li>
Yang et al. (2019)
Zhilin Yang, Zihang Dai, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov,
and Quoc V. Le. 2019.
<a href="https://papers.nips.cc/paper/2019/file/dc6a7e655d7e5840e66733e9ee67cc69-Paper.pdf">XLNet: Generalized Autoregressive Pretraining for Language
Understanding</a>.
In <em>NeurIPS 2019</em>, pages 5754–5764.
</li>
<li>
Yang et al. (2017)
Zichao Yang, Zhiting Hu, Ruslan Salakhutdinov, and Taylor Berg-Kirkpatrick.
2017.
<a href="http://proceedings.mlr.press/v70/yang17d.html">Improved
variational autoencoders for text modeling using dilated convolutions</a>.
In <em>ICML 2017</em>, volume 70, pages 3881–3890.
</li>
<li>
Zhang et al. (2020)
Jingqing Zhang, Yao Zhao, Mohammad Saleh, and Peter J. Liu. 2020.
<a href="http://proceedings.mlr.press/v119/zhang20ae.html">PEGASUS: Pre-training with Extracted Gap-sentences for
Abstractive Summarization</a>.
In <em>ICML 2020</em>, pages 11328–11339.
</li>
<li>
Zhu et al. (2019)
Wanrong Zhu, Zhiting Hu, and Eric Xing. 2019.
<a href="http://arxiv.org/abs/1901.00158">Text infilling</a>.
<em>arXiv preprint arXiv:1901.00158</em>.
</li>
<li>
Zhu et al. (2015)
Yukun Zhu, Ryan Kiros, Richard S. Zemel, Ruslan Salakhutdinov, Raquel Urtasun,
Antonio Torralba, and Sanja Fidler. 2015.
<a href="https://doi.org/10.1109/ICCV.2015.11">Aligning books and
movies: Towards story-like visual explanations by watching movies and reading
books</a>.
In <em>ICCV 2015</em>, pages 19–27.
</li>
</ul>
</section>
<section>
<h2>
Appendix A Pretraining Setting</h2>
<section>
<h3>
A.1 Datasets</h3>
<p>To train GLM<math></math> and GLM<math></math>, we use BookCorpus <cite>Zhu et al. (<a href="#bib.bib50">2015</a>)</cite> and Wikipedia used by BERT <cite>Devlin et al. (<a href="#bib.bib9">2019</a>)</cite>.</p>
<p>To train GLM<math></math>, we follow the pretraining datasets of RoBERTa <cite>Liu et al. (<a href="#bib.bib21">2019</a>)</cite>, which consist of BookCorups <cite>Zhu et al. (<a href="#bib.bib50">2015</a>)</cite>,Wikipedia (16GB), CC-News (the English portion of the CommonCrawl News dataset<sup>3</sup><sup>3</sup>3<a href="https://commoncrawl.org/2016/10/news-dataset-available">https://commoncrawl.org/2016/10/news-dataset-available</a> 76GB), OpenWebText (web content extracted from URLs shared on Reddit with at least three upvotes<cite>Gokaslan and Cohen (<a href="#bib.bib13">2019</a>)</cite>, 38GB) and Stories (subset of CommonCrawl data filtered to match the story-like style of Winograd schemas <cite>Trinh and Le (<a href="#bib.bib42">2019</a>)</cite>, 31GB). The Stories dataset is no longer publicly available<sup>4</sup><sup>4</sup>4<a href="https://github.com/tensorflow/models/tree/archive/research/lm_commonsense#1-download-data-files">https://github.com/tensorflow/models/tree/archive/research/lm_commonsense#1-download-data-files</a>. Therefore, we remove the Stories dataset and replace OpenWebText with OpenWebText2<sup>5</sup><sup>5</sup>5<a href="https://openwebtext2.readthedocs.io/en/latest">https://openwebtext2.readthedocs.io/en/latest</a> (66GB). The CC-News dataset is not publicly available and we use the CC-News-en published by <cite>Mackenzie et al. (<a href="#bib.bib22">2020</a>)</cite>. All the datasets used total 158GB of uncompressed texts, close in size to RoBERTa’s 160GB datasets.</p>
</section>
<section>
<h3>
A.2 Hyperparameters</h3>
<figure>
<figcaption>Table 7: Hyperparameters for pretraining</figcaption>
<table>
<tr>
<td>Hyperparameters</td>
<td>GLM <math></math>
</td>
<td>GLM <math></math>
</td>
<td>GLM <math></math>
</td>
</tr>
<tr>
<td>Number of Layers</td>
<td>12</td>
<td>24</td>
<td>24</td>
</tr>
<tr>
<td>Hidden size</td>
<td>768</td>
<td>1024</td>
<td>1024</td>
</tr>
<tr>
<td>FFN inner hidden size</td>
<td>3072</td>
<td>4096</td>
<td>4096</td>
</tr>
<tr>
<td>Attention heads</td>
<td>12</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>Attention head size</td>
<td>64</td>
<td>64</td>
<td>64</td>
</tr>
<tr>
<td>Dropout</td>
<td>0.1</td>
<td>0.1</td>
<td>0.1</td>
</tr>
<tr>
<td>Attention Dropout</td>
<td>0.1</td>
<td>0.1</td>
<td>0.1</td>
</tr>
<tr>
<td>Warmup Steps</td>
<td>6k</td>
<td>8k</td>
<td>30K</td>
</tr>
<tr>
<td>Peak Learning Rate</td>
<td>4e-4</td>
<td>2e-4</td>
<td>4e-4</td>
</tr>
<tr>
<td>Batch Size</td>
<td>1024</td>
<td>1024</td>
<td>8192</td>
</tr>
<tr>
<td>Weight Decay</td>
<td>0.1</td>
<td>0.1</td>
<td>0.01</td>
</tr>
<tr>
<td>Max Steps</td>
<td>120k</td>
<td>200k</td>
<td>250k</td>
</tr>
<tr>
<td>Learning Rate Decay</td>
<td>Cosine</td>
<td>Cosine</td>
<td>Cosine</td>
</tr>
<tr>
<td>Adam <math></math>
</td>
<td>1e-6</td>
<td>1e-6</td>
<td>1e-6</td>
</tr>
<tr>
<td>Adam <math></math>
</td>
<td>0.9</td>
<td>0.9</td>
<td>0.9</td>
</tr>
<tr>
<td>Adam <math></math>
</td>
<td>0.98</td>
<td>0.98</td>
<td>0.98</td>
</tr>
<tr>
<td>Gradient Clipping</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
</table>
</figure>
<p>The hyperparameters for GLM<math></math> and GLM<math></math> are similar to those used by BERT. For trade-off of training speed and fair comparison with BERT (batch size 256 and 1,000,000 training steps), we use batch size of 1024 and 200,000 training steps for GLM<math></math>. Since GLM<math></math> is smaller, we reduce the number of training steps to 120,000 to speed up pre-training. The hyperparameters for GLM<math></math> and GLM<math></math> are the same as those of GLM<math></math>. The hyperparameters except Transformer architecture for GLM<math></math> and GLM<math></math> are the same as those of GLM<math></math>. The models are trained on 64 V100 GPUs for 200K steps with batch size of 1024 and maximum sequence length of 512, which takes about 2.5 days for GLM<math></math>.</p>
<p>To train GLM<math></math>, we follow most of the hyperparameters of RoBERTa. The main difference includes: (1) Due to resource limit, we only pre-train GLM <math></math> for 250,000 steps, which are half of RoBERTa and BART’s training steps, and close to T5 in number of trained tokens. (2) We use cosine decay instead of linear decay for learning rate scheduling (3) We additionally apply gradient clipping with value 1.0.</p>
<p>The hyperparameters for all the pre-training settings are summarized in <a href="#A1.T7">Table 7</a>.</p>
</section>
<section>
<h3>
A.3 Implementation</h3>
<p>Our pretraining implementation is based on Megatron-LM <cite>Shoeybi et al. (<a href="#bib.bib39">2019</a>)</cite> and DeepSpeed <cite>Rasley et al. (<a href="#bib.bib33">2020</a>)</cite>. We include our code in the supplementary material. Due to the size limit of supplementary material, we cannot include the pretrained models, but will make them public available in the future.</p>
</section>
</section>
<section>
<h2>
Appendix B Downstream Tasks</h2>
<section>
<h3>
B.1 SuperGLUE</h3>
<p>The SuperGLUE benchmark consists of 8 NLU tasks. We formulate them as blank infilling tasks, following <cite>Schick and Schütze (<a href="#bib.bib36">2020b</a>)</cite>. Table <a href="#A2.T8">8</a> shows the cloze questions and verbalizers we used in our experiments. For 3 tasks (ReCoRD, COPA, and WSC), the answer may consist of multiple tokens, and for the other 5 tasks, the answer is always a single token.</p>
<p>When finetuning GLM on the SuperGLUE tasks, we construct the input using the cloze questions in Table <a href="#A2.T8">8</a> and replace the blank with a [MASK] token. Then we compute the score of generating each answer candidate. For the 5 single-token tasks, the score is defined to be the logit of the verbalizer token. For the 3 multi-token tasks, we use the sum of the log-probabilities of the verbalizer tokens. Thanks to the autoregressive blank infilling mechanism we proposed, we can obtain all the log-probabilities in one pass. Then we compute the cross entropy loss using the groundtruth label and update the model parameters.</p>
<p>For the baseline classifiers, we follow the standard practice to concatenate the input parts of each task (such as the premise and hypothesis for textual entailment, or the passage, question and answer for ReCORD and MultiRC) and add a classification layer on top of the [CLS] token representation. We also implemented cloze-style finetuning for the other pre-trained models, but the performance was usually similar to the standard classifier, as we shown in the ablation study. Models with blank-infilling objectives, such as T5 and our GLM, benefits more from converting the NLU tasks into cloze questions. Thus for T5 and GLM, we report the performance after such conversion in our main results.</p>
<figure>
<figcaption>Table 8: Cloze questions and verbalizers for the 8 SuperGLUE tasks used in our experiments. <sup>∗</sup> denotes the answer contains multiple tokens.</figcaption>
<table>
<tr>
<td>Dataset</td>
<td>Task</td>
<td>
Cloze Question
</td>
<td>
Verbalizers
</td>
</tr>
<tr>
<td>ReCoRD<sup>∗</sup>
</td>
<td>Question answering</td>
<td>
[passage <math></math>] [cloze question <math></math>]
</td>
<td>
Answer candidates
</td>
</tr>
<tr>
<td>COPA<sup>∗</sup>
</td>
<td>Causal reasoning</td>
<td>
“[choice <math></math>]” or “[choice <math></math>]”? [premise <math></math>], so  .
</td>
<td>
<math></math> / <math></math>
</td>
</tr>
<tr>
<td>WSC<sup>∗</sup>
</td>
<td>Coreference resolution</td>
<td>
[sentence <math></math>] The pronoun ‘<math></math>’ refers to  .
</td>
<td>
Noun <math></math>
</td>
</tr>
<tr>
<td>RTE</td>
<td>Textual entailment</td>
<td>
“[hypothesis <math></math>]”? <math></math>  , “[premise <math></math>]”
</td>
<td>
“yes” (entailment), “no” (not entailment)
</td>
</tr>
<tr>
<td>BoolQ</td>
<td>Question answering</td>
<td>
[passage <math></math>]. Question: <math></math>? Answer:  .
</td>
<td>
“yes” / “no”
</td>
</tr>
<tr>
<td>WiC</td>
<td>Word sense disambiguation</td>
<td>
“[sentence <math></math>]” / “[sentence <math></math>]” Similar sense of [word <math></math>]?  .
</td>
<td>
“yes” / “no”
</td>
</tr>
<tr>
<td>CB</td>
<td>Textual entailment</td>
<td>
“[hypothesis <math></math>]”? <math></math>  , “[premise <math></math>]”
</td>
<td>
“yes” (entailment), “no” (contradiction), “maybe” (neutral)
</td>
</tr>
<tr>
<td>MultiRC</td>
<td>Question answering</td>
<td>
[passage <math></math>]. Question: <math></math>? Is it [answer <math></math>]?  .
</td>
<td>
“yes” / “no”
</td>
</tr>
</table>
</figure>
</section>
<section>
<h3>
B.2 Sequence-to-Sequence</h3>
<p>Fot the text summarization task, we use the dataset Gigaword <cite>Rush et al. (<a href="#bib.bib34">2015</a>)</cite> for model fine-tuning and evaluation. We finetune GLM<math></math> on the training set for 4 epochs with AdamW optimizer. The learning rate has a peak value of 3e-5, warm-up over the 6% training steps and a linear decay. We also use label smoothing with rate 0.1 <cite>Pereyra et al. (<a href="#bib.bib27">2017</a>)</cite>. The maximum document length is 192 and the maximum summary length is 32. During decoding, we use beam search with beam size of 5 and remove repeated trigrams. We tweak the value of length penalty on the development set. The evaluation metrics are the F1 scores of Rouge-1, Rouge-2, and Rouge-L <cite>Lin (<a href="#bib.bib19">2004</a>)</cite> on the test set.</p>
<p>For the question generation task, we use the SQuAD 1.1 dataset <cite>Rajpurkar et al. (<a href="#bib.bib32">2016</a>)</cite> and follow the dataset split of <cite>Du et al. (<a href="#bib.bib12">2017</a>)</cite>. The optimizer hyperparameters are the same as those of abstractive summarization. The maximum passage length is 464 and the maximum question length is 48. During decoding, we use beam search with beam size 5 and tweak the value of length penalty on the development set. The evaluation metrics are the scores of BLEU-1, BLEU-2, BLEU-3, BLEU-4 <cite>Papineni et al. (<a href="#bib.bib26">2002</a>)</cite>, METEOR <cite>Denkowski and Lavie (<a href="#bib.bib8">2014</a>)</cite> and Rouge-L <cite>Lin (<a href="#bib.bib19">2004</a>)</cite>.</p>
<p>Results of T5<math></math> on XSum are obtained by running the summarization script provided by Huggingface transformers<sup>6</sup><sup>6</sup>6<a href="https://github.com/huggingface/transformers/tree/master/examples/pytorch/summarization">https://github.com/huggingface/transformers/tree/master/examples/pytorch/summarization</a>. All the other results of baselines on seq2seq tasks are obtained from the corresponding papers.</p>
</section>
<section>
<h3>
B.3 Text Infilling</h3>
<p>We follow <cite>Shen et al. (<a href="#bib.bib38">2020</a>)</cite> and evaluate text infilling performance on the Yahoo Answers dataset <cite>Yang et al. (<a href="#bib.bib47">2017</a>)</cite>, which contains 100K/10K/10K documents for train/valid/test respectively. The average document length is 78 words. To construct the text infilling task, we randomly mask a given ratio <math></math> of each document’s tokens and the contiguous masked tokens are collapsed into a single blank. We finetune GLM<math></math> on the training set for 5 epochs with dynamic masking, i.e. the blanks are randomly generated at training time. Similar to the sequence-to-sequence experiments, we use an AdamW optimizer with a peak learning rate 1e-5 and 6% warm-up linear scheduler.</p>
<p>For comparison with previous work, we use the same test set constructed by <cite>Shen et al. (<a href="#bib.bib38">2020</a>)</cite>. The evaluation metric is the BLEU score of the infilled text against the original document. We compare with two baselines: (1) BERT, which learns a left-to-right language model to generate the masked tokens on top of the blank representation, and (2) BLM proposed by <cite>Shen et al. (<a href="#bib.bib38">2020</a>)</cite>, which can fill in the blank with arbitrary trajectories.</p>
</section>
<section>
<h3>
B.4 Language Modeling</h3>
<p>We evaluate the model’s ability of language modeling with perplexity on BookWiki and accuracy on the LAMBDA dataset <cite>Paperno et al. (<a href="#bib.bib25">2016</a>)</cite>.</p>
<p>Perplexity is an evaluation criterion that has been well studied for language modeling. Perplexity is the exponentiation of the average cross entropy of a corpus.</p>
<table>
<tbody><tr>
<td></td>
<td><math></math></td>
<td></td>
<td>(4)</td>
</tr></tbody>
</table>
<p>where <math></math>. Since transformers can only operate on a window of fixed input size <math></math>, we cannot fully calculate <math></math> and can only calculate <math></math>. Even calculating this value for each token is prohibitively expensive, since we need to conduct <math></math> evaluations of <math></math>-size contexts. To improve evaluation efficiency, we adopt <em>overlapping evaluation</em>, where we advance the sliding windows by some overlap <math></math> each time and only compute the cross entropy loss for the last <math></math> tokens of the window. In our experiments we set <math></math> for all the models.</p>
<p>LAMBDA is a cloze-style dataset to test the ability of long-range dependency modeling. Each example is a passage consisting of 4-5 sentences with the last word missing and the model is required to predict the last word of the passage. Since we use WordPiece tokenization, a word can be split into several subword units. We use teacher forcing and consider the prediction correct only when all the predicted tokens are correct.</p>
</section>
</section>
<section>
<h2>
Appendix C Results on Other NLU Benchmarks</h2>
<p>GLUE <cite>Wang et al. (<a href="#bib.bib44">2018</a>)</cite> is another widely-used NLU benchmark, including single sentence tasks (e.g. sentiment analysis <cite>Socher et al. (<a href="#bib.bib40">2013</a>)</cite>) and sentence pair tasks (e.g. text similarity <cite>Cer et al. (<a href="#bib.bib5">2017</a>)</cite> and natural language inference <cite>Williams et al. (<a href="#bib.bib45">2018</a>); Dagan et al. (<a href="#bib.bib7">2005</a>)</cite>). The benchmark is usually considered as less challenging than SuperGLUE. SQuAD <cite>Rajpurkar et al. (<a href="#bib.bib32">2016</a>, <a href="#bib.bib31">2018</a>)</cite> is an extractive question answering benchmark. We further compare GLM with BERT on the two benchmarks.</p>
<p>The results on GLUE and SQuAD are shown in <a href="#A3.T9">Tables 9</a> and <a href="#A3.T10">10</a>. On the two benchmarks, GLM can still outperform BERT with the same amount of parameters, but with a smaller margin.</p>
<figure>
<figcaption>Table 9: Results on the GLUE dev set.</figcaption>
<table>
<tr>
<td>Model</td>
<td>MNLI</td>
<td>QNLI</td>
<td>QQP</td>
<td>RTE</td>
<td>SST-2</td>
<td>MRPC</td>
<td>CoLA</td>
<td>STS-B</td>
<td>Avg</td>
</tr>
<tr>
<td>BERT<math></math>
</td>
<td>86.6</td>
<td>92.3</td>
<td>91.3</td>
<td>73.6</td>
<td>93.2</td>
<td>88.0</td>
<td>60.6</td>
<td>90.0</td>
<td>84.4</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>86.7</td>
<td>92.8</td>
<td>91.5</td>
<td>74.0</td>
<td>93.5</td>
<td>90.0</td>
<td>61.4</td>
<td>90.7</td>
<td>85.1</td>
</tr>
</table>
</figure>
<figure>
<figcaption>Table 10: Results on the SQuAD v1.1/v2.0 dev sets.</figcaption>
<table>
<tr>
<td>Model</td>
<td>
 
SQuAD v1.1
EM/F1
</td>
<td>
 
SQuAD v2.0
EM/F1
</td>
</tr>
<tr>
<td>BERT<math></math>
</td>
<td>80.8 / 88.5</td>
<td>73.7 / 76.3</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>
81.5 / 88.6
</td>
<td>
74.7 / 77.8
</td>
</tr>
<tr>
<td>BERT<math></math>
</td>
<td>84.1 / 90.9</td>
<td>79.0 / 81.8</td>
</tr>
<tr>
<td>GLM<math></math>
</td>
<td>
85.4 / 91.6
</td>
<td>
80.3 / 83.3
</td>
</tr>
</table>
</figure>
</section>
<section>
<h2>
Appendix D Text Generation Samples</h2>
<p>We show texts generated by GLM<math></math> given unseen contexts randomly sampled from the test set. We use top-<math></math> random sampling with <math></math> for generation and set maximum sequence length to 512. Some of the texts are cut short.</p>
<h6>
Example D.1.
</h6>
<p>The Wyoming State Legislature is the legislative branch of the U.S. State of Wyoming.</p>
<p>GLM: It consists of a state senate and a house of representatives. As of 2019, state senators are Steve Kish, Joe L. Williams, and Linda S. Bollens. Members of the Wyoming State Legislature are elected from single-member districts representing the majority of the state. The current state senate members are: In recent years, there have been four changes to the senate. The most recent is the creation of a six-seat district that includes all or part of the following: In the 2009 elections, the state senate members were elected to six-year terms. The current state house members are: The Wyoming Constitution assigns certain powers to the governor. Most notably, the governor is president of the senate and governor. However, if the governor desires to appoint a member to the Wyoming state senate, a law authorizes the governor to do so. The governor of Wyoming holds no legislative power but has the power to veto lawmakers, which is not limited to the veto of laws. Under the wyoming state constitution, the governor can veto the actions of the other members of the wyoming house of representatives. The governor can also appoint members of the wyoming senate. In addition, the governor can appoint members of the Wyoming house of representatives. Wyoming’s constitution provides that the governor can appoint a member of the wyoming state senate to the wyoming supreme court, and the chairman of the wyoming senate.</p>
<h6>
Example D.2.
</h6>
<p>Jonathan Terry is a television and film actor.</p>
<p>GLM: He was a voice actor for the “X-Men" cartoon series. He was also a voice actor for “the Simpsons" as well as “the marvelous misadventures of superman. He also has voiced characters in “the legend of korra" He has appeared on several television series, including “the simpsons", “the x-files", “heroes" and “the simpsons movie" as the character captain billy higgledy-pig, and the web series “krusty mysteries" as the character Colonel Trungus. He wrote for “the Guardian" newspaper. Jonathan Terry was born in London. Terry grew up in Surrey, England and attended the University of Sussex in the United Kingdom, graduating with a degree in english literature. He was a guest lecturer at King’s College London, and then took two years of acting courses at the brit school of acting to prepare for his future career in the entertainment industry. Terry first appeared in the TV series “the Simpsons" as the character captain Billy Higgledy-pig, but his character was only a one-time recurring character in the series’ first six seasons. He later appeared as a regular for the show’s final six seasons, and has been a frequent guest in the show since. He appeared in the first few episodes of “" as the character major Jack Ryan. He has also appeared as part of the supporting cast of several episodes of “the secret life of pets". He has also worked on “the simpsons" TV show since “the simpsons movie", most notably playing the roles of Captain Skeletor and the ghost of the same name. He plays characters in several films, including “", “", “" and “". He has appeared in music videos for the killers in 1993, the pretenders in 1995, and in the TV shows “the royal" and “the bill".</p>
<h6>
Example D.3.
</h6>
<p>Corona was a station along the port Washington branch of the long island rail road in the Corona section of queens, New York City. It was one of two stations built by the flushing railroad in Corona, this one having been at Grand Avenue (later called National Avenue, now National Street ) and 45th Avenue.</p>
<p>GLM: It had a brick entrance building next to the tracks, and one platform with 2 side platforms. The station burned down and was rebuilt in 1908. The station closed on september 15, 1927, with the train service transferred from Grand Avenue to 45th Avenue. There were plans to build a subway extension to Corona, but it was never built. In the 1980s, two stations were constructed on the line, Corona Road and Corona Park. The new Corona station opened in 1988, and the original Corona station was demolished.</p>
<h6>
Example D.4.
</h6>
<p>Robert Lee Smith (born July 5, 1938) is a former American football cornerback in the national football league. He played for the Los Angeles Rams (1962–1965) and the Detroit Lions (1965–1966). He was also a kick and punt returner.</p>
<p>GLM: In his four-year NFL career, he played in 33 games and started 14, registering 62 career interceptions. He completed his NFL career with five interceptions. Smith was born in La Canada Flintridge, Michigan, in 1938. He attended Bishop O’ Dowd high school in Flintridge. Smith’ s father was a pharmacist. He graduated from Michigan State University in 1958 with a degree in business administration. Smith played for the Michigan Wolverines football team from 1959 to 1963. In his two years as a reserve cornerback, he led the conference in interceptions with five. In 1962, he set the Wolverines’ all-time interception record with 13, and was second overall in the 1962 season’s Heisman Trophy voting. Smith also won the Dick Butkus award as the nation’s outstanding linebacker. In 1961, the “Los Angeles Times" wrote that Smith “is an outstanding pass rusher, with an average of almost 100 yards per punt return." Smith was inducted into the university of Michigan athletic hall of honor in 1989 and the national football foundation hall of fame in 1991. He was elected to the Michigan sports hall of fame in 1995. Smith earned the honor because of his accomplishments prior to his NFL career. He was one of four Michigan players honored as first-overall selections in the 1964 NFL draft. The others were Joe Namath, Bill Nelsen, and Jerry Kramer. In 1966, the NFL gave players $300,000 a season to play football. After his rookie season, he was not selected to play in the 1966 pro bowl. On January 13, 1966, the Rams traded smith to the Detroit Lions for Paul Hornung, and later that year he was traded to the Lions for Ray “the Lion" Jones in exchange for Linebacker Jim “the Hawk" Johnson. On September 10, 1968, he was traded back to Los Angeles for a second round pick in the 1970 draft. He was also traded to the St. Louis Cardinals for a second round pick in the 1970 draft. On June 2, 1970 he was cut by the Cardinals. On November 15, 1970, the Los Angeles Rams acquired Smith from the Lions in exchange for Linebacker Tony Harris. The Rams waived Smith during the September 1, 1972 offseason. Smith’s number at Michigan State was # 7 in 1969.</p>
</section>
<a href="/html/2103.10359">◄</a>
<a href="/"><img src="/assets/ar5iv.png"/></a>
<a href="/feeling_lucky">Feeling<br/>lucky?</a>
<a href="/log/2103.10360">Conversion<br/>report</a>
<a href="https://github.com/dginev/ar5iv/issues/new?template=improve-article--arxiv-id-.md&amp;title=Improve+article+2103.10360">Report<br/>an issue</a>
<a href="https://arxiv.org/abs/2103.10360">View original<br/>on arXiv</a><a href="/html/2103.10361">►</a>
